# 0,0,0,0,0,0,0,0,2,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,3,0,0,0,3,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,3,3,0,3,0,3,2,3,3,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,2,1,1,0,0,3,2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,1,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),byrow=T,nrow=50)
# Data are in matrix âmydataâ, one female per row, with coding as follows:
# 0 = female not observed;
# 1 = female observed with no fawn;
# 2 = female observed with 1 fawn;
# 3 = female observed with 2 fawns;
# 4 = female observed with 3 fawns.
# number of individuals
n <- dim(mydata)[[1]]
# number of capture occasions
K <- dim(mydata)[[2]]
# compute date of first capture
e <- NULL
for (i in 1:n){
temp <- 1:K
e <- c(e,min(temp[mydata[i,]>=1]))}
# compute age
age <- matrix(NA,nrow=nrow(mydata),ncol=ncol(mydata))
for (i in 1:nrow(age)){
for (j in e[i]:ncol(age)){
if (j == e[i]) age[i,j] <- 1 # yearling
if ((j > e[i]) & (j <= e[i]+5)) age[i,j] <- 2 # prime-age
if (j > e[i]+5) age[i,j] <- 3 # senescent
}
}
##################################################################
# 2 - NIMBLE MODEL
##################################################################
# load Nimble (see Nimble manual for installation)
library(nimble)
# input code (identical to WinBUGS/JAGS code)
multistatect <- modelCode({
# BUGS code of the state-space formulation
# of capture-recapture models (O. Gimenez, May, 2011)
# notation used
# OBSERVATIONS
# 0 = female not observed;
# 1 = female observed with no fawn;
# 2 = female observed with 1 fawn;
# 3 = female observed with 2 fawns;
# 4 = female observed with 3 fawns.
# STATES
# NB = non-breeding female;
# B1 = female breeding with 1 fawn;
# B2 = female breeding with 2 fawns;
# B3 = female breeding with 3 fawns;
# B4 = dead.
# parameters
# phiNB  survival prob. of non-breeding individuals  / by age
# phiB  survival prob. of breeding individuals / by age
# pNB  detection prob. of NB individuals
# pB  detection prob. of B individuals
# psiNBB1 transition prob. from NB to B1
# psiB1B2 transition prob. from B1 to B2
# psiB2B3 transition prob. from B2 to B3
# psiB1B3 transition prob. from B1 to B3
# piNB prob. of being in initial state NB
##############
# LIKELIHOOD
##############
# probabilities for each initial state
px0[1] <- 1 # prob. of being in initial state NB
px0[2] <- 0 # prob. of being in initial state B1
px0[3] <- 0 # prob. of being in initial state B2
px0[4] <- 0 # prob. of being in initial state B3
px0[5] <- 0 # because of the conditioning on first capture, prob. of being in initial state dead is 0
# probabilities of observations at a given occasion given states at this occasion
po[1,1] <- 1-pNB
po[1,2] <- pNB
po[1,3] <- 0
po[1,4] <- 0
po[1,5] <- 0
po[2,1] <- 1-pB
po[2,2] <- 0
po[2,3] <- pB
po[2,4] <- 0
po[2,5] <- 0
po[3,1] <- 1-pB
po[3,2] <- 0
po[3,3] <- 0
po[3,4] <- pB
po[3,5] <- 0
po[4,1] <- 1-pB
po[4,2] <- 0
po[4,3] <- 0
po[4,4] <- 0
po[4,5] <- pB
po[5,1] <- 1
po[5,2] <- 0
po[5,3] <- 0
po[5,4] <- 0
po[5,5] <- 0
for (i in 1:N)  # for each female
{
# estimated probabilities of initial states are the proportions in each state at first capture occasion
alive[i,First[i]] ~ dcat(px0[1:5])
for (j in (First[i]+1):Years)  # loop over time
{
# define age-dependent survival probabilities
# if ageij = 1, then phi = phi-young
# if ageij = 2, then phi = phi-subadult
# if ageij = 3, then phi = phi-adult
phiNB[i,j-1] <- phiNBy*nimbleEquals(age[i,j-1],1)+phiNBsa*nimbleEquals(age[i,j-1],2)+phiNBa*nimbleEquals(age[i,j-1],3)
phiB[i,j-1] <- 0 * nimbleEquals(age[i,j-1],1) + phiBsa * nimbleEquals(age[i,j-1],2) + phiBa * nimbleEquals(age[i,j-1],3)
# probabilities of states at a given occasion given states at previous occasion
# uses mulitnomial logit for the transition probabilities between breeding states
px[1,i,j-1,1] <- phiNB[i,j-1] * 1/(1+exp(alpha[1,1])+exp(alpha[1,2])+exp(alpha[1,3]))
px[1,i,j-1,2] <- phiNB[i,j-1] * exp(alpha[1,1])/(1+exp(alpha[1,1])+exp(alpha[1,2])+exp(alpha[1,3]))
px[1,i,j-1,3] <- phiNB[i,j-1] * exp(alpha[1,2])/(1+exp(alpha[1,1])+exp(alpha[1,2])+exp(alpha[1,3]))
px[1,i,j-1,4] <- phiNB[i,j-1] * exp(alpha[1,3])/(1+exp(alpha[1,1])+exp(alpha[1,2])+exp(alpha[1,3]))
px[1,i,j-1,5] <- 1-phiNB[i,j-1]
px[2,i,j-1,1] <- phiB[i,j-1] * exp(alpha[2,1])/(1+exp(alpha[2,1])+exp(alpha[2,2])+exp(alpha[2,3]))
px[2,i,j-1,2] <- phiB[i,j-1] * 1/(1+exp(alpha[2,1])+exp(alpha[2,2])+exp(alpha[2,3])) #
px[2,i,j-1,3] <- phiB[i,j-1] * exp(alpha[2,2])/(1+exp(alpha[2,1])+exp(alpha[2,2])+exp(alpha[2,3]))
px[2,i,j-1,4] <- phiB[i,j-1] * exp(alpha[2,3])/(1+exp(alpha[2,1])+exp(alpha[2,2])+exp(alpha[2,3]))
px[2,i,j-1,5] <- 1-phiB[i,j-1]
px[3,i,j-1,1] <- phiB[i,j-1] * exp(alpha[3,1])/(1+exp(alpha[3,1])+exp(alpha[3,2])+exp(alpha[3,3]))
px[3,i,j-1,2] <- phiB[i,j-1] * exp(alpha[3,2])/(1+exp(alpha[3,1])+exp(alpha[3,2])+exp(alpha[3,3]))
px[3,i,j-1,3] <- phiB[i,j-1] * 1/(1+exp(alpha[3,1])+exp(alpha[3,2])+exp(alpha[3,3])) #
px[3,i,j-1,4] <- phiB[i,j-1] * exp(alpha[3,3])/(1+exp(alpha[3,1])+exp(alpha[3,2])+exp(alpha[3,3]))
px[3,i,j-1,5] <- 1-phiB[i,j-1]
px[4,i,j-1,1] <- phiB[i,j-1] * exp(alpha[4,1])/(1+exp(alpha[4,1])+exp(alpha[4,2])+exp(alpha[4,3]))
px[4,i,j-1,2] <- phiB[i,j-1] * exp(alpha[4,2])/(1+exp(alpha[4,1])+exp(alpha[4,2])+exp(alpha[4,3]))
px[4,i,j-1,3] <- phiB[i,j-1] * exp(alpha[4,3])/(1+exp(alpha[4,1])+exp(alpha[4,2])+exp(alpha[4,3]))
px[4,i,j-1,4] <- phiB[i,j-1] * 1/(1+exp(alpha[4,1])+exp(alpha[4,2])+exp(alpha[4,3]))
px[4,i,j-1,5] <- 1-phiB[i,j-1]  #
px[5,i,j-1,1] <- 0
px[5,i,j-1,2] <- 0
px[5,i,j-1,3] <- 0
px[5,i,j-1,4] <- 0
px[5,i,j-1,5] <- 1
## STATE EQUATIONS ##
# draw states at j given states at j-1
# 		Q[i,j] ~ dcat(px[alive[i,j-1],i,j-1,1:5])
## OBSERVATION EQUATIONS ##
# draw observations at j given states at j
mydata[i,j] ~ dcat(po[alive[i,j],1:5])
for(k in 1:5) {
mydata_probs[i,j,k] <- equals(alive[i,j],1)*po[1,k] + equals(alive[i,j],2)*po[2,k] + equals(alive[i,j],3)*po[3,k] + equals(alive[i,j],4)*po[4,k] + equals(alive[i,j],5)*po[5,k]
}
mydata[i,j] ~ dcat(mydata_probs[i,j,1:5])
}
}
#########
# PRIORS
#########
pNB ~ dunif(0, 1) # non-breeder detectability
pB ~ dunif(0, 1) # breeder detectability
phiBsa ~ dunif(0, 1) # breeder survival sub-adult
phiBa ~ dunif(0, 1) # breeder survival adult
phiNBy ~ dunif(0, 1) # non-breeder survival young
phiNBsa ~ dunif(0, 1) # non-breeder survival sub-adult
phiNBa ~ dunif(0, 1) # non-breeder survival adult
# transition probabilites - multinomial logit
for (i in 1:4){
for (j in 1:3){
alpha[i,j] ~ dnorm(0,0.1)
}
}
})
##################################################################
# 3 - RUN NIMBLE
##################################################################
# constants
constants <- list(N=n,Years=K,First=e,age=as.matrix(age))
# data
data <- list(mydata=as.matrix(mydata+1))
# initial values
alive = mydata
for (i in 1:n) {
for (j in 1:K) {
if (j > e[i] & mydata[i,j]==0) {alive[i,j] = which(rmultinom(1, 1, c(1/4,1/4,1/4,1/4))==1)}
if (j < e[i]) {alive[i,j] = NA}
}
}
alive <- as.matrix(alive)
inits <- list(pB=0.5,phiNBy=0.3,alive=alive)
# compile model (see Nimble manual)
mdef <- nimbleModel(multistatect, name='as', constants=constants, data=data, inits=inits, returnDef = TRUE, debug=F)
source('loadAllCode.R')
mydata <- matrix(
c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,0,1,0,0,
0,0,0,0,0,0,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,1,0,0,0,
0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,0,0,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,
0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,
0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,1,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,
0,0,1,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,1,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,
0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,
0,0,0,1,1,0,0,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,1,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),byrow=T,nrow=50)
# repro<-matrix(
# c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,1,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,2,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,2,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,2,0,2,2,1,0,0,
# 0,0,0,0,0,0,0,1,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,2,2,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,3,3,2,2,2,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,0,3,2,1,0,1,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,2,0,0,2,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,1,0,
# 0,0,0,0,0,3,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,3,1,0,3,3,3,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,3,3,3,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,2,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,3,0,2,2,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,2,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,1,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,2,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,2,0,1,2,3,2,2,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,2,0,0,3,1,2,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,3,3,1,3,3,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,
# 0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,2,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,3,0,0,0,3,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,3,3,0,3,0,3,2,3,3,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,2,1,1,0,0,3,2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,1,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
# 0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),byrow=T,nrow=50)
# Data are in matrix âmydataâ, one female per row, with coding as follows:
# 0 = female not observed;
# 1 = female observed with no fawn;
# 2 = female observed with 1 fawn;
# 3 = female observed with 2 fawns;
# 4 = female observed with 3 fawns.
# number of individuals
n <- dim(mydata)[[1]]
# number of capture occasions
K <- dim(mydata)[[2]]
# compute date of first capture
e <- NULL
for (i in 1:n){
temp <- 1:K
e <- c(e,min(temp[mydata[i,]>=1]))}
# compute age
age <- matrix(NA,nrow=nrow(mydata),ncol=ncol(mydata))
for (i in 1:nrow(age)){
for (j in e[i]:ncol(age)){
if (j == e[i]) age[i,j] <- 1 # yearling
if ((j > e[i]) & (j <= e[i]+5)) age[i,j] <- 2 # prime-age
if (j > e[i]+5) age[i,j] <- 3 # senescent
}
}
##################################################################
# 2 - NIMBLE MODEL
##################################################################
# load Nimble (see Nimble manual for installation)
library(nimble)
# input code (identical to WinBUGS/JAGS code)
multistatect <- modelCode({
# BUGS code of the state-space formulation
# of capture-recapture models (O. Gimenez, May, 2011)
# notation used
# OBSERVATIONS
# 0 = female not observed;
# 1 = female observed with no fawn;
# 2 = female observed with 1 fawn;
# 3 = female observed with 2 fawns;
# 4 = female observed with 3 fawns.
# STATES
# NB = non-breeding female;
# B1 = female breeding with 1 fawn;
# B2 = female breeding with 2 fawns;
# B3 = female breeding with 3 fawns;
# B4 = dead.
# parameters
# phiNB  survival prob. of non-breeding individuals  / by age
# phiB  survival prob. of breeding individuals / by age
# pNB  detection prob. of NB individuals
# pB  detection prob. of B individuals
# psiNBB1 transition prob. from NB to B1
# psiB1B2 transition prob. from B1 to B2
# psiB2B3 transition prob. from B2 to B3
# psiB1B3 transition prob. from B1 to B3
# piNB prob. of being in initial state NB
##############
# LIKELIHOOD
##############
# probabilities for each initial state
px0[1] <- 1 # prob. of being in initial state NB
px0[2] <- 0 # prob. of being in initial state B1
px0[3] <- 0 # prob. of being in initial state B2
px0[4] <- 0 # prob. of being in initial state B3
px0[5] <- 0 # because of the conditioning on first capture, prob. of being in initial state dead is 0
# probabilities of observations at a given occasion given states at this occasion
po[1,1] <- 1-pNB
po[1,2] <- pNB
po[1,3] <- 0
po[1,4] <- 0
po[1,5] <- 0
po[2,1] <- 1-pB
po[2,2] <- 0
po[2,3] <- pB
po[2,4] <- 0
po[2,5] <- 0
po[3,1] <- 1-pB
po[3,2] <- 0
po[3,3] <- 0
po[3,4] <- pB
po[3,5] <- 0
po[4,1] <- 1-pB
po[4,2] <- 0
po[4,3] <- 0
po[4,4] <- 0
po[4,5] <- pB
po[5,1] <- 1
po[5,2] <- 0
po[5,3] <- 0
po[5,4] <- 0
po[5,5] <- 0
for (i in 1:N)  # for each female
{
# estimated probabilities of initial states are the proportions in each state at first capture occasion
alive[i,First[i]] ~ dcat(px0[1:5])
for (j in (First[i]+1):Years)  # loop over time
{
# define age-dependent survival probabilities
# if ageij = 1, then phi = phi-young
# if ageij = 2, then phi = phi-subadult
# if ageij = 3, then phi = phi-adult
phiNB[i,j-1] <- phiNBy*nimbleEquals(age[i,j-1],1)+phiNBsa*nimbleEquals(age[i,j-1],2)+phiNBa*nimbleEquals(age[i,j-1],3)
phiB[i,j-1] <- 0 * nimbleEquals(age[i,j-1],1) + phiBsa * nimbleEquals(age[i,j-1],2) + phiBa * nimbleEquals(age[i,j-1],3)
# probabilities of states at a given occasion given states at previous occasion
# uses mulitnomial logit for the transition probabilities between breeding states
px[1,i,j-1,1] <- phiNB[i,j-1] * 1/(1+exp(alpha[1,1])+exp(alpha[1,2])+exp(alpha[1,3]))
px[1,i,j-1,2] <- phiNB[i,j-1] * exp(alpha[1,1])/(1+exp(alpha[1,1])+exp(alpha[1,2])+exp(alpha[1,3]))
px[1,i,j-1,3] <- phiNB[i,j-1] * exp(alpha[1,2])/(1+exp(alpha[1,1])+exp(alpha[1,2])+exp(alpha[1,3]))
px[1,i,j-1,4] <- phiNB[i,j-1] * exp(alpha[1,3])/(1+exp(alpha[1,1])+exp(alpha[1,2])+exp(alpha[1,3]))
px[1,i,j-1,5] <- 1-phiNB[i,j-1]
px[2,i,j-1,1] <- phiB[i,j-1] * exp(alpha[2,1])/(1+exp(alpha[2,1])+exp(alpha[2,2])+exp(alpha[2,3]))
px[2,i,j-1,2] <- phiB[i,j-1] * 1/(1+exp(alpha[2,1])+exp(alpha[2,2])+exp(alpha[2,3])) #
px[2,i,j-1,3] <- phiB[i,j-1] * exp(alpha[2,2])/(1+exp(alpha[2,1])+exp(alpha[2,2])+exp(alpha[2,3]))
px[2,i,j-1,4] <- phiB[i,j-1] * exp(alpha[2,3])/(1+exp(alpha[2,1])+exp(alpha[2,2])+exp(alpha[2,3]))
px[2,i,j-1,5] <- 1-phiB[i,j-1]
px[3,i,j-1,1] <- phiB[i,j-1] * exp(alpha[3,1])/(1+exp(alpha[3,1])+exp(alpha[3,2])+exp(alpha[3,3]))
px[3,i,j-1,2] <- phiB[i,j-1] * exp(alpha[3,2])/(1+exp(alpha[3,1])+exp(alpha[3,2])+exp(alpha[3,3]))
px[3,i,j-1,3] <- phiB[i,j-1] * 1/(1+exp(alpha[3,1])+exp(alpha[3,2])+exp(alpha[3,3])) #
px[3,i,j-1,4] <- phiB[i,j-1] * exp(alpha[3,3])/(1+exp(alpha[3,1])+exp(alpha[3,2])+exp(alpha[3,3]))
px[3,i,j-1,5] <- 1-phiB[i,j-1]
px[4,i,j-1,1] <- phiB[i,j-1] * exp(alpha[4,1])/(1+exp(alpha[4,1])+exp(alpha[4,2])+exp(alpha[4,3]))
px[4,i,j-1,2] <- phiB[i,j-1] * exp(alpha[4,2])/(1+exp(alpha[4,1])+exp(alpha[4,2])+exp(alpha[4,3]))
px[4,i,j-1,3] <- phiB[i,j-1] * exp(alpha[4,3])/(1+exp(alpha[4,1])+exp(alpha[4,2])+exp(alpha[4,3]))
px[4,i,j-1,4] <- phiB[i,j-1] * 1/(1+exp(alpha[4,1])+exp(alpha[4,2])+exp(alpha[4,3]))
px[4,i,j-1,5] <- 1-phiB[i,j-1]  #
px[5,i,j-1,1] <- 0
px[5,i,j-1,2] <- 0
px[5,i,j-1,3] <- 0
px[5,i,j-1,4] <- 0
px[5,i,j-1,5] <- 1
## STATE EQUATIONS ##
# draw states at j given states at j-1
# 		Q[i,j] ~ dcat(px[alive[i,j-1],i,j-1,1:5])
## OBSERVATION EQUATIONS ##
# draw observations at j given states at j
# 		mydata[i,j] ~ dcat(po[alive[i,j],1:5])
for(k in 1:5) {
mydata_probs[i,j,k] <- equals(alive[i,j],1)*po[1,k] + equals(alive[i,j],2)*po[2,k] + equals(alive[i,j],3)*po[3,k] + equals(alive[i,j],4)*po[4,k] + equals(alive[i,j],5)*po[5,k]
}
mydata[i,j] ~ dcat(mydata_probs[i,j,1:5])
}
}
#########
# PRIORS
#########
pNB ~ dunif(0, 1) # non-breeder detectability
pB ~ dunif(0, 1) # breeder detectability
phiBsa ~ dunif(0, 1) # breeder survival sub-adult
phiBa ~ dunif(0, 1) # breeder survival adult
phiNBy ~ dunif(0, 1) # non-breeder survival young
phiNBsa ~ dunif(0, 1) # non-breeder survival sub-adult
phiNBa ~ dunif(0, 1) # non-breeder survival adult
# transition probabilites - multinomial logit
for (i in 1:4){
for (j in 1:3){
alpha[i,j] ~ dnorm(0,0.1)
}
}
})
##################################################################
# 3 - RUN NIMBLE
##################################################################
# constants
constants <- list(N=n,Years=K,First=e,age=as.matrix(age))
# data
data <- list(mydata=as.matrix(mydata+1))
# initial values
alive = mydata
for (i in 1:n) {
for (j in 1:K) {
if (j > e[i] & mydata[i,j]==0) {alive[i,j] = which(rmultinom(1, 1, c(1/4,1/4,1/4,1/4))==1)}
if (j < e[i]) {alive[i,j] = NA}
}
}
alive <- as.matrix(alive)
inits <- list(pB=0.5,phiNBy=0.3,alive=alive)
# compile model (see Nimble manual)
mdef <- nimbleModel(multistatect, name='as', constants=constants, data=data, inits=inits, returnDef = TRUE, debug=F)
source('loadAllCode.R')
workingdir <- 'C:/Users/Daniel/Documents/Dropbox/My Documents from Berkeley computer/R/9 multievent CR model from Olivier'
load(file.path(workingdir, 'multievent_CR_datafile.RData'))
source(file.path(workingdir, 'multievent_CR_model_definition.R'))
## generate inits, constants, data
alive <- mydata
for (i in 1:n) {
for (j in 1:K) {
if (j > e[i] & mydata[i,j]==0) {alive[i,j] <- which(rmultinom(1, 1, c(1/4,1/4,1/4,1/4))==1)}
if (j < e[i]) {alive[i,j] <- NA}
}
}
constants <- list(N=n, Years=K, First=e, age=as.matrix(age))
data      <- list(mydata=as.matrix(mydata+1))
inits     <- list(pB=0.5, phiNBy=0.3, alive=alive)
## build NIMBLE model and MCMC
system.time(modelDef <- nimbleModel(multistateModelCode, constants=constants, data=data, inits=inits, returnDef = TRUE))  ## 16 mins
system.time(Rmodel <- modelDef$newModel(data=data))  ## 3 mins
# system.time(Cmodel <- compileNimble(Rmodel))  ## 15 mins
system.time(mcmcSpec <- MCMCspec(Rmodel, print = TRUE))  ## 1.5 mins
mcmcSpec$resetMonitors()
mcmcSpec$addMonitors(c('pNB', 'pB', 'phiBsa', 'phiBa', 'phiNBy', 'phiNBsa', 'phiNBa', 'alpha'))
system.time(Rmcmc <- buildMCMC(mcmcSpec))  ## 5 mins
# system.time(Cmcmc <- compileNimble(Rmcmc, project = Rmodel))  ## 100 mins
Rmodel$pB
Rmodel$phiNBsa
Rmodel$phiNBa
Rmodel$phiNBy
Rmodel$alive
inits$alive
Rmodel$alive <- inits$alive
Rmodel$alive
Rmcmc
nfVar(Rmcmc, 'nodeInitFunctions')
nfVar(Rmcmc, 'nodeInitFunctions')$contents
nfVar(Rmcmc, 'nodeInitFunctions')$contentsList
length(nfVar(Rmcmc, 'nodeInitFunctions'))
length(nfVar(Rmcmc, 'RHSonlyInitFunctions'))
nodeInitFunsList <- nfVar(Rmcmc, 'nodeInitFunctions')$contentsList
nodeInitFunsList[[1]]
nfVar(nodeInitFunsList[[1]], 'node')
for(i in seq_along(nodeInitFunsList)) { print(nfVar(nodeInitFunsList[[i]], 'node')); nodeInitFunsList[[i]]() }
