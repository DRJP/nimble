% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/normConst_build.R
\name{getNormConst}
\alias{getNormConst}
\title{Calculates a normalizing constant for a NIMBLE model using a MVN approximation to the posterior.}
\usage{
getNormConst(model, burnIn = 1000,
  mcmcControl = structure(list(adaptInterval = 100), .Names =
  "adaptInterval"))
}
\arguments{
\item{model}{A nimble model}

\item{burnIn}{burn-in used for MCMC sampler}

\item{mcmcControl}{list passed to \code{MCMCSpec}, a nimble function that builds the MCMC sampler. See \code{help(MCMCSpec)} for more details}
}
\description{
Takes a nimble model and integrates over all stochastic, non-data nodes. The run() method returns an approximation of log of the normalizing constant.
The getVar() method returns the standard deviation of the importance weights used to approximate the normalizing constant.
}
\details{
getNormConst returns an importance sampling approximation to the log of the normalizing constant of a model (f(data|model)).  The posterior distribution of all stochastic nodes is approximated
by a multivariate normal distribution.  In cases where this approximation is not appropriate, the estimate of the normalizing constant will not be reliable.
For this reason, it is important to ensure that the MCMC used to obtain posterior samples has converged.
An idea of the Monte Carlo error in the approximation can be gotten by the getVar() method, which will return the variance of the log of the
importance sampling weights used for the approximation.
}
\section{Runtime Arguments}{

	\describe{
	\item{\code{mcmcSamps}}	{
   number of iterations to run the MCMC algorithm for.
	}
 \item{\code{importanceSamps}}	{
   number of importance samples to use.
	}
}
}
\examples{
pumpCode <- nimbleCode({
 for (i in 1:N){
     theta[i] ~ dgamma(alpha,beta);
     lambda[i] <- theta[i]*t[i];
     x[i] ~ dpois(lambda[i])
 }
 alpha ~ dexp(1.0);
 beta ~ dgamma(0.1,1.0);
})

pumpConsts <- list(N = 10,
              t = c(94.3, 15.7, 62.9, 126, 5.24,
                31.4, 1.05, 1.05, 2.1, 10.5))

pumpData <- list(x = c(5, 1, 5, 14, 3, 19, 1, 1, 4, 22))

pumpInits <- list(alpha = 1, beta = 1,
             theta = rep(0.1, pumpConsts$N))
pumpModel <- nimbleModel(code = pumpCode, name = 'pump', constants = pumpConsts,
                  data = pumpData, inits = pumpInits)

compileNimble(pumpModel)
getPumpNormConst <- getNormConst(pump, burnIn = 1000, mcmcControl = list(adaptInterval = 100))
cgetPumpNormConst <- compileNimble(getPumpNormConst, project = pumpModel)
normConstEst <- cgetPumpNormConst$run(10000,10000)
normConstCV <- cgetPumpNormConst$getCV()
}
\author{
Nicholas Michaud
}
\references{
Gelman and Meng, Statistical Science Vol. 13, No. 2, 163-185, 1998.
}

