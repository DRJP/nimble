<<<<<<< HEAD
% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/nimbleFunction_Rexecution.R
\name{nfVar}
\alias{nfVar}
\alias{nfVar<-}
\title{Access or set a member variable of a nimbleFunction created during \code{setup}}
=======
% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in RtmpCszhwx/fileb8615493aea
\name{nfVar}
\alias{nfVar}
\alias{nfVar<-}
\title{Internal way to access or set a member variable of a nimbleFunction created during \code{setup}.  Normally in NIMBLE code you would use \code{nf$var} instead of \code{nfVar(nf, var)}.}
>>>>>>> upstream/devel
\usage{
nfVar(nf, varName)
}
\arguments{
<<<<<<< HEAD
\item{nf}{A specialized nimbleFunction, i.e. a function returned by executing a function returned from \code{nimbleFunction} with \code{setup} arguments}

\item{varName}{A character string naming a variable in the \code{setup} function.}
}
\value{
whatever varName is in  the nimbleFunction nf.
}
\description{
Access or set a member variable of a specialized nimbleFunction, i.e. a variable passed to or created during the \code{setup} function that is used in run code or preserved by \code{setupOutputs}.  Works in R for any variable and in NIMBLE for numeric variables.
}
\details{
When \code{nimbleFunction} is called and a \code{setup} function is provided, then \code{nimbleFunction} returns a function.  That function is a generator that should be called with arguments to the \code{setup} function and returns another function that will execute the \code{run} function.  The \code{run} function and any other \code{methods} provided can use objects created or passed to \code{setup}.  \code{nfVar} provides direct access to those objects by name.

In R, \code{nfVar} can retrieve anything in \code{setup}, including models, other nimbleFunctions, and vectors of node lists.  In NIMBLE, it can only retrieve numeric variables

For access to methods of \code{nf}, see \code{nfMethod}.

For more information, see \code{?nimbleFunction} and the NIMBLE User Manual.
=======
  \item{nf}{A specialized nimbleFunction, i.e. a function
  returned by executing a function returned from
  \code{nimbleFunction} with \code{setup} arguments}

  \item{varName}{A character string naming a variable in
  the \code{setup} function.}
}
\value{
whatever varName is in the nimbleFunction nf.
}
\description{
Access or set a member variable of a specialized
nimbleFunction, i.e. a variable passed to or created during
the \code{setup} function that is used in run code or
preserved by \code{setupOutputs}.  Works in R for any
variable and in NIMBLE for numeric variables.
}
\details{
When \code{nimbleFunction} is called and a \code{setup}
function is provided, then \code{nimbleFunction} returns a
function.  That function is a generator that should be
called with arguments to the \code{setup} function and
returns another function with \code{run} and possibly other
member functions.  The member functions can use objects
created or passed to \code{setup}.  During internal
processing, the NIMBLE compiler turns some cases of
\code{nf$var} into \code{nfVar(nf, var)}. These provide
direct access to setup variables (member data).
\code{nfVar} is not typically called by a NIMBLE user or
programmer.

For internal access to methods of \code{nf}, see
\link{nfMethod}.

For more information, see \code{?nimbleFunction} and the
NIMBLE User Manual.
>>>>>>> upstream/devel
}
\examples{
nfGen1 <- nimbleFunction(
    setup = function(A) {
    B <- matrix(rnorm(4), nrow = 2)
    setupOutputs(B) ## preserves B even though it is not used in run-code
   },
   run = function() {
      print('This is A', A, '\\n')
})

nfGen2 <- nimbleFunction(
  setup = function() {
    nf1 <- nfGen1(1000)
  },
  run = function() {
      print('accessing A:', nfVar(nf1, 'A'))
      nfVar(nf1, 'B')[2,2] <<- -1000
      print('accessing B:', nfVar(nf1, 'B'))
   })

nf2 <- nfGen2()
nf2()
Cnf2 <- compileNimble(nf2)
Cnf2()
}
\author{
NIMBLE development team
}

