% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/distributions_processInputList.R
\name{registerDistributions}
\alias{registerDistributions}
\title{Add user-supplied distributions for use in NIMBLE BUGS models}
\usage{
registerDistributions(distributionsInputList)
}
\arguments{
\item{distributionsInputList}{a list in the form of that shown in \code{nimble:::distributionsInputList} with required field \code{BUGSdist} and optional fields \code{Rdist}, \code{altParams}, \code{discrete}, \code{pqAvail}, \code{types}. See Details for more information. If only one distribution is supplied it may be a list rather than a list containing a list.}
}
\description{
Register distributional information so that NIMBLE can process
user-supplied distributions in BUGS model code
}
\details{
\itemize{
\item{\code{BUGSdist}} {
a character string in the form of the density name (starting with 'd') followed by the names of the parameters in parentheses. When alternative parameterizations are given in \code{Rdist}, this should be an exhaustive list of the unique parameter names from all possible parameterizations.
}
\item{\code{Rdist}} {
an optional character vector with one or more alternative specifications of the density; each alternative specification can be an alternative name for the density, a different ordering of the parameters, different parameter name(s), or an alternative parameterization. In the latter case, the character string in parentheses should provide a given reparameterization as comma-separated name = value pairs, one for each default parameter, where name is the name of the default parameter and value is a mathematical expression relating the default parameter to the alternative parameters or other default parameters. The default parameters should correspond to the input arguments of the nimbleFunctions provided as the density and random generation functions. The maethematical expression can use any of the math functions allowed in NIMBLE (see the User Manual) as well as user-supplied nimbleFunctions without setup code.
}
\item{\code{discrete}} {
a optional logical indicating if the distribution is that of a discrete random variable. If not supplied, distribution is assumed to be for a continuous random variable.
}
\item{\code{pqAvail}} {
a optional logical indicating if distribution (CDF) and quantile (inverse CDF) functions are provided as nimbleFunctions. These are required for one to be able to use truncated versions of the distribution. Only applicable for univariate distributions. If not supplied, assumed to be FALSE.
}
\item{\code{altParams}} {
a character vector of comma-separated 'name = value' pairs that provide the mathematical expressions relating non-default parameters to default parameters. These inverse functions are used for MCMC conjugacy calculations when a conjugate relationship is expressed in terms of non-default parameters (such as the precision for normal-normal conjugacy). If not supplied, the system will still functional but at a possible loss of efficiency in certain algorithms.
}
\item{\code{types}} {
a character vector of comma-separated 'name = input' pairs indicating the type and dimension of the random variable and parameters (including default and alternative parameters). 'input' should take the form 'integer(d)' or 'double(d)', where 'd' is 0 for scalars, 1 for vectors, 2 for matrices. 'name' should be either 'value' to indicate the random variable itself or the parameter name to indicate a given parameter.  Required for multivariate distributions or when parameters are not scalars. By default all parameters are assumed double(0) and values (the random variable) are assumed either double(0) or integer(0) depending on whether the distribution is for a discrete random variable.
}
}
}
\examples{
dmyexp <- nimbleFunction(
   run = function(x = double(0), rate = double(0), log_value = integer(0)) {
       returnType(double(0))
       logProb <- log(rate) - x*rate
       if(log_value) {
           return(logProb)
       } else {
           return(exp(logProb))
       }
   })
rmyexp <- nimbleFunction(
   run = function(n = integer(0), rate = double(0)) {
       returnType(double(0))
       if(n != 1) nimPrint("rmyexp only allows n = 1; using n = 1.")
       dev <- runif(1, 0, 1)
       return(-log(1-dev) / rate)
   }
   )
registerDistributions(list(
    dmyexp = list(
              BUGSdist = "dmyexp(rate, scale)",
              Rdist = "dmyexp(rate = 1/scale)",
              altParams = "scale = 1/rate",
              pqAvail = FALSE),
code <- BUGScode({
    y ~ dmyexp(rate = r)
    r ~ dunif(0, 100)
})
m <- nimbleModel(code, inits = list(r = 1), data = list(y = 2))
calculate(m, 'y')
m$r <- 2
calculate(m, 'y')
m$resetData()
simulate(m, 'y')
m$y
}
\author{
Christopher Paciorek
}

